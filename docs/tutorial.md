# Redmatch Tutorial

In this tutorial we will use a REDCap form to capture patient data and transform it into a FHIR representation using Redmatch.

## Prerequisites

### REDCap server

This tutorial uses a simple REDCap form that captures patient data to show how Redmatch can be used to transform it into FHIR resources. A REDCap server is required to run the tutorial. Also, the [FHIR Ontology External Module](https://github.com/aehrc/redcap_fhir_ontology_provider) needs to be installed in the REDCap server to run the tutorial, but is not required to use Redmatch. The external module is available in the official [REDCap Repository of External Modules](https://redcap.vanderbilt.edu/consortium/modules/) and can be installed directly from REDCap. Please refer to the REDCap documentation for details on the installation procedure. The module's [GitHub page](https://github.com/aehrc/redcap_fhir_ontology_provider) has documentation on configuration and usage.

### FHIR terminology server

Redmatch uses a FHIR terminology server to validate the transformation rules, to support mapping of local codes to standardised terminology and to provide auto-complete functionality to the rules editor (this functionality is currently under construction). By default Redmatch uses a [public instance](https://r4.ontoserver.csiro.au) of CSIRO's terminology server, [Ontoserver](http://ontoserver.csiro.au/). This is an easy way to get Redmatch up and running but it is not recommended to be used in production. Ontoserver is a commercial product and it is available as a Docker image. It is free for use in Australia but a paid license is required elsewhere.

You can replace Ontoserver with any free FHIR terminology server that supports R4. The code systems required for validation is generated by the application.

### Docker

Redmatch is distributed as Docker images. A basic understanding of Docker is required to complete this tutorial.

## Setting up the sample REDCap project

You need to have access to a REDCap instance and have the right permissions to create a project. Installation instructions for REDCap can be found [here](https://projectredcap.org/software/requirements/). This tutorial were developed using REDCap version 8.10.0.

First, click on the "New Project" button in the top menu and create a new REDCap project as shown here:

![Create new REDCap project](img/redcap_create_project.png?raw=true "Create new REDCap project")

Click on the "Data Dictionary" button. This will take you to the data dictionary tab where you can download and upload data dictionary files, as shown here:

![Upload data dictionary](img/redcap_upload_data_dictionary.png?raw=true "Upload data dictionary")

Click on the "Choose file" button at the bottom of the page, select the sample data dictionary provided [here](RedmatchTutorial_DataDictionary_2020-04-23.csv) and then click on the "Upload File" button. You will be asked to commit your changes as shown here:

![Commit changes](img/redcap_commit_changes.png?raw=true "Commit changes")

Click on the "Commit Changes" button to complete the upload of the data dictionary. You can now inspect the form that was created by navigating to the Online Designer page on your project. You should have a single form called Patient Information, as shown here:

![Patient information form](img/redcap_patient_information_form.png?raw=true "Patient information form")

If you click on the "Patient Information" link you will be able to explore the form definition, as shown here:

![Patient information form details](img/redcap_patient_information_form_detail.png?raw=true "Patient information form details")

Redmatch projects are associated with a REDCap report. This allows excluding fields that are not meant to be part of the FHIR representation. Create a report by clicking on the "Data Exports, Reports, and Stats" button on the left hand side menu and then on the "Create New Report" tab. Give the report any name you want and use the "Quick Add" button to add all the elements of the Patient Information form to the report (in this case we are not excluding anything), as shown here:

![REDCap report definition](img/redcap_report_def.png?raw=true "REDCap report definition")

Click on the "Save Report" button and then on the "View Report" button. We haven't added any records yet so this should display the "View Report" tab with no results.

You should then create some sample patients. You can do this by clicking on the "Add / Edit Records" link on the left hand side menu. Once you have created entries, rerun the report to see the results. We created two sample patients, John and Jane Doe, as shown here:

![REDCap report results](img/redcap_report_results.png?raw=true "REDCap report results")

Finally, Redmatch communicates with REDCap through its API and requires a token to authenticate. You need to request this token to your REDCap administrator. If you are using a local instance you can generate an API token by clicking on the "API" button on the left hand side menu and then on the "Create API token now" button. The token should look like this:

![REDCap API token](img/redcap_api_token.png?raw=true "REDCap API token")

## Running Redmatch

Redmatch is distributed as Docker images, one for the backend and one for the user interface. A Docker Compose file that is configured to run in your local machine is available in the project root. To run Redmatch locally, download the `docker-compose.yml` file from the repository and run

```
% docker-compose up -d
```

The Redmatch UI will be available in [http://localhost:8888](http://localhost:8888).

## Creating a Redmatch project

To create a new Redmatch project click on the ADD PROJECT button. A new project dialog will be displayed, as shown here:

![New Redmatch project dialog](img/redmatch_tutorial_new.png?raw=true "New Redmatch project dialog")

A project requires four parameters:

1. A name. This can be any name that will help you identify the project.
2. The id of the report you defined in REDCap. Unfortunately, there is no mechanism to query the report ids through the REDCap API. The easiest way to find the report id is to run the report in REDCap and look at the URL. For example, in this case `http://localhost:8888/redcap/redcap_v8.10.0/DataExport/index.php?pid=36&report_id=7` the report id is 7.
3. The URL of the REDCap API endpoint.
4. The token to access the REDCap API.

If the operation is successful, the new project will be available in the list of projects, as shown here:

![Redmatch projects](img/redmatch_tutorial_projects.png?raw=true "Redmatch projects")

## Writing transformation rules

The first step in the process of transforming REDCap forms into FHIR resources is writing the Redmatch rules. This tutorial will show some of the features available in the transformation language using the sample REDCap project.

### Patient details

We will start by writing rules to transform basic patient information. An example of the REDCap form is shown here:

![REDCap tutorial patient information](img/redmatch_tutorial_redcap_patient.png?raw=true "REDCap tutorial patient information")

Click on the _Rules_ tab and enter the following:

```
TRUE { 
  Patient<p>:
    * identifier.type = CONCEPT_LITERAL(http://hl7.org/fhir/v2/0203|MC)
    * identifier.type.text = 'Medicare Number'
    * identifier.system = 'http://ns.electronichealth.net.au/id/medicare-number'
    * identifier.value = VALUE(pat_medicare)
}

VALUE(patient_dead) = 1 {
  NOTNULL(pat_dead_date) {
    Patient<p>: * deceasedDateTime = VALUE(pat_dead_date)
  } ELSE {
    Patient<p>: * deceasedBoolean = TRUE
  }
}

VALUE(pat_dead) = 0 {
  Patient<p>: * deceasedBoolean = FALSE
}

NOTNULL(pat_sex) {
  Observation<sex>:
    * code = CONCEPT_LITERAL(http://snomed.info/sct|429019009)
    * valueCodeableConcept = CONCEPT_SELECTED(pat_sex)
    * subject = REF(Patient<p>)
}
```

Press the _Save_ button and wait for the server to compile the rules. You should see an error as shown here:

![Redmatch rules](img/redmatch_tutorial_rules_patient_error.png?raw=true "Redmatch Rules")

The compiler checks that the rules are syntactically correct and also that the REDCap fields that are referenced in the rules exist. In this case, the field _patient\_dead_ does not exist in the REDCap form and therefore the compiler generates an error. Change the field name to _pat\_dead_ and press the _Save_ button again. The rules should compile successfully this time.

Let's go through the rules in more detail, using the second rule as an example:

```
VALUE(pat_dead) = 1 {
  NOTNULL(pat_dead_date) {
    Patient<p>: * deceasedDateTime = VALUE(pat_dead_date)
  } ELSE {
    Patient<p>: * deceasedBoolean = TRUE
  }
}
```

The first part of a rule is a condition that determines if the rule will run or not. In this case the condition is `VALUE(pat_dead) = 1`. This means that rule runs if the value of the REDCap field _pat\_dead_ is equal to _1_, which means that the _True_ radio button is selected. 

The body of a rule is contained inside the curly brackets and indicates which FHIR resource should be created if the condition is true. Rules can also be nested, so the body of a rule can be another rule. In this case the sub-rule is evaluated if the REDCap field _pat_dead_date_ is non-empty, i.e., if the user has entered a date.

The sub-rule has both a body and an _ELSE_ clause. Similar to a programming language, if the condition is _true_ the main body is executed and otherwise the body in the _ELSE_ clause is. In both cases a _Patient_ resource, identified with the variable _p_, is created. The variable can be used to reference the same resource from different rules.

The lines after the colon are attributes of the resource. In this case the _deceased_ attribute is populated. Notice that because this is a value\[x\] type, it can be set to different types. The sub-rule states that if the main body is executed, the deceased attribute will be populated with the date the patient died. Otherwise, a boolean value will be used to indicate that the patient is deceased. Each line starts with an asterisk followed by the full path of the attribute to set, an equals sign and an expression. The compiler uses the FHIR meta-model to ensure these paths are valid.

There are several expressions that can be used to assign values to the attributes. In this example, two different expressions are used: a boolean literal and values form the form. A boolean literal is just a static boolean value (TRUE or FALSE). If the date when the patient died is set in the REDCap form then the expression `VALUE(pat_dead_date)` will extract the date from the REDCap field. Redmatch will try to transform the values in the forms to the data type of the target FHIR attribute, unless the types are not compatible, in which case a compiler error will be generated.


### Conditions

We will now write additional rules to transform patient diagnoses. An example of the REDCap form is shown here:

![REDCap tutorial diagnoses](img/redmatch_tutorial_rules_dx.png?raw=true "REDCap tutorial diagnoses")

This section of the form uses REDCap's [FHIR Ontology External Module](https://github.com/aehrc/redcap_fhir_ontology_provider) to capture coded diagnoses. The plugin allows creating auto-complete style fields that use a FHIR terminology server to search for codes. The pattern that is implemented in this example also allows adding free text if a code is not found. The free text fields are hidden initially and are only displayed if the user explicitly indicates that a concept was not found. Also, because we want to capture one or more diagnoses, a drop down and branching logic are used to display the number of diagnoses that user wants to enter.

Add the following to your rules:

```
VALUE(dx_num) > 0 {
  REPEAT(1..2: x)
  NOTNULL(dx_${x}) {
    VALUE(dx_${x}) = '_NRF_' {
      Condition<c${x}>: 
        * code.text = VALUE(dx_text_${x})
        * subject = REF(Patient<p>)
    } ELSE {
      Condition<c${x}>: 
        * code = CONCEPT(dx_${x})
        * subject = REF(Patient<p>)
    }
  }
}
```

Let's look at these rules in more detail. The outermost condition, `VALUE(dx_num) > 0`, indicates that the rule should only run if one or more diagnoses have been entered. Inside this rule we find a sub-rule that gets repeated. The `REPEAT(1..2: x)` clause runs the rule twice and assigns the values `1` the first time it's run and `2` the second time. This variable is used to refer to REDCap fields that are repeated, such as `dx_1` and `dx_2`, without having to write separate rules for each repetition.

The condition `VALUE(dx_${x}) = '_NRF_'` looks for a predefined value used by the plugin that indicates that the user attempted to search for a code but couldn't find one. In this case, the `Condition.code` attribute in the target resource is populated with the free text that was entered. Otherwise, the `CONCEPT(dx_${x})` expression extracts the concept selected with the plugin.

The final thing worth pointing out is the use of references. The diagnoses that are generated should be linked back to the patient. This is achieved using the `REF(Patient<p>)` expression.


### Phenotype

The final set of rules in this tutorial will transform a section of the form that uses checkboxes to capture a patient's phenotype into FHIR observations. An example of the REDCap form is shown here:

![REDCap tutorial phenotype](img/redmatch_tutorial_rules_phenotype.png?raw=true "REDCap tutorial phenotype")

Add the following to your rules:

```
REPEAT(1..4: x)
NOTNULL(phenotype___${x}) {
  Observation<obs${x}>:
    * status = CODE_LITERAL(final)
    * code = CONCEPT(phenotype___${x})
    * interpretation = CONCEPT_LITERAL(http://terminology.hl7.org/CodeSystem/v3-ObservationInterpretation|POS)
}
```

In this case a repeat expression is used to test if each checkbox is checked or not, using the `NOTNULL(phenotype___${x})` expression. Each individual checkbox has an identifier that is made up of the main field id, in this case `phenotype`, and the value of each choice.

The `code` attribute is populated using the `CONCEPT` expression which tells Redmatch that this value should be coded. Because the checkboxes are just Redcap local codes, the platform creates a mapping that the user will need to complete before being able to export the data into FHIR. The `status` attribute is always the same regardless of the values in the REDCap form and there it is populated using the `CODE_LITERAL(final)` expression. This is also the case with the `interpretation` attribute, except that the the data type in this case is `CodeableConcept` and therefore a `CONCEPT_LITERAL` expression is used.


For more details and a list of all the expressions available in the language please check the [reference documentation](reference.md).

## Mapping

Save the rules, check that there are no compilation errors and then click on the _MAPPINGS_ tab. Each value is typically bound to a [value set](https://www.hl7.org/fhir/valueset.html). In this example we will use two value sets: `BiologicalSexValueSet` for the sex of the patient and `Human Phenotype Ontology Phenotypic Abnormalities` for the patient's phenotype. Find these value sets for each of the fields and then complete the mappings by searching for the corresponding concept. When you are done, click on the _Save_ button. The completed mappings should look like this:

![REDCap tutorial mappings](img/redmatch_tutorial_mappings_complete.png?raw=true "REDCap tutorial mappings")

## Exporting to FHIR

Once the transformation rules and mappings are complete, the transformation can be run to produce FHIR resources. Click on the _EXPORT_ tab and then click on the EXPORT button. This will generate a ZIP file with the resulting resources in [NDJSON](http://ndjson.org/) format. Each resource type is saved in a separate file. In this case, three files are generated: `Condition.ndjson`, `Observation.ndjson` and `Patient.ndjson`. This formats allows directly importing this data into the [Pathling FHIR Analytics Platform](https://pathling.csiro.au/docs/import.html).

That's it! You have successfully transformed a REDCap project into standardised FHIR resources by defining transformation rules. To learn more about the Redmatch grammar checkout the [Redmatch reference documentation](reference.md).
